#!/bin/bash
# @TODO test with more complex datasets and zvols
# GLOBAL SETTINGS
ZSYNC_PREFIX="bk"
ZSYNC_SSHCONNECT_TIMEOUT=3
ZSYNC_SSHPARAMS="-T -o BatchMode=yes -o ConnectTimeout=$ZSYNC_SSHCONNECT_TIMEOUT"
ZSYNC_RETENTION=3 # keep last 3
ZSYNC_REC="-R"
## RETURN CODES
ZSYNC_ERR_REACH=100
ZSYNC_ERR_TIMESYNC=101
ZSYNC_ERR_DEVIATION=102
ZSYNC_DO_INIT=0
ZSYNC_DO_ROLLING=1
## LOGGING
ZSYNC_DEBUG=1

debugprint(){
  if [[ "$ZSYNC_DEBUG" != "" ]] ; then
    printf "%s\n" "DEBUG: $*"
  fi
}
errprint(){
        printf "%s\n" "ERROR: $*" >&2
}

errquit(){
  errprint "$*"
  exit 1
}

# @TODO
# TIMESTAMPS on snapshots bc rename changes the creation date
# fonction qui egalise 
# better to get latest:
# zfs list -t snapshot -H -o guid | tail -1

usage() {
  cat << HEREDOC
Usage: $(basename "$0") srcfs desthost destfs
Ex: $(basename "$0") tank 10.1.1.2 tank/backups

Synchronize two ZFS pools from master FS to backup.
Will create backup FS if it doesn't exists.

HEREDOC
}


main() {
  typeset srcfs desthost destfs

  [[ $# != 3 ]] && errquit "$(usage)"

  srcfs="$1"
  desthost="$2"
  destfs="$3"
  
  # starts here
  zsync_verify $srcfs $desthost $destfs
  res=$?
  case "$res" in
    $ZSYNC_ERR_REACH)
      errquit "Backup '$desthost' is not reachable: "$msg""
    ;;
    $ZSYNC_ERR_TIMESYNC)
      errquit "Master ($localtime) and backup ($remotetime) are ${timediff}sec out of time sync"
    ;;
    $ZSYNC_ERR_DEVIATION)
      zsync_equalize $srcfs $desthost $destfs
    ;;
    $ZSYNC_DO_INIT)
      zsync_init $srcfs $desthost $destfs
    ;;
    $ZSYNC_DO_ROLLING)
      zsync_roll $srcfs $desthost $destfs
    ;;
  esac
}

# Main function
# Sanity checks to verify MASTER and BACKUP fs
zsync_verify() {
  typeset srcfs desthost destfs localtime remotetime

  srcfs="$1"
  desthost="$2"
  destfs="$3"

  # reachability
  debugprint "ssh $ZSYNC_SSHPARAMS "root@$desthost" exit 2>&1"
  msg=$(ssh $ZSYNC_SSHPARAMS "root@$desthost" exit 2>&1)
  if [[ $? -ne 0 ]]; then
    return $ZSYNC_ERR_REACH
  fi

  # time sync
  localtime=$(date +%s)
  remotetime="$(ssh $ZSYNC_SSHPARAMS "root@$desthost" "date +%s")"

  timediff=$(( localtime - remotetime ))
  timediff=$(( timediff < 0 ? -timediff : timediff ))
  debugprint "$deshost out of sync of $timediff"

  if [[ $timediff -gt 100 ]]; then
    return $ZSYNC_ERR_TIMESYNC
  fi

  # is an init ?
  debugprint "zfs list -H -r "$srcfs" -t snapshot -o name 2>&1 | grep -E "${ZSYNC_PREFIX}_" | wc -l"
  is_init=$(zfs list -H -r "$srcfs" -t snapshot -o name 2>&1 | grep -E "${ZSYNC_PREFIX}_" | wc -l)
  debugprint "is_init: $is_init"

  if [[ $is_init == 0 ]]; then
    return $ZSYNC_DO_INIT
  else
    # latest guid are equal ?
    debugprint "Checking if latest guids are equal"
    localguid=$(zfs list -t snapshot -H -d 1 -o guid | tail -1)
    remoteguid=$(ssh $ZSYNC_SSHPARAM "root@$desthost" zfs list -t snapshot -H -d 1 -o guid | tail -1)
    debugprint "Local guid: $localguid - Remote guid: $remoteguid"

    if [[ $localguid == $remoteguid ]]; then
      return $ZSYNC_DO_ROLLING
    else
      # if not there's DEVIATION
      return $ZSYNC_ERR_DEVIATION
    fi
  fi
}

# cas d egalisation
# 1: master n'a pas reussi a envoyer son snap (connectivite) et est en avance [OK]
# 2: master a ete snapshot et l'ordre avant _0 _1 _2 est devenu _1 _2 => fo corriger les 2
# 3: master a pris zpool destroy, mais backup est toujours up => envoie full backup
# 4: backup a pris zpool destroy, mais master est toujours up => envoie full master
# fo aussi expliquer comment chercher dans les clones
# fo aussi passer sur prox des que c potable
zsync_equalize(){
  typeset srcfs desthost destfs local_creation remote_creation localguid remoteguid

  srcfs="$1"
  desthost="$2"
  destfs="$3"

  printf "Equalizing each pools ...\n"

  # is there a snapshot 0 (none when we rolled back one or the other) ? @TODO

  # compare most recent snap_0 to find out which is late (latest guid are different)
  local_creation=$(zfs list -t snapshot -H -d 1 -o creation | tail -1)
  local_creation=$(date -d "$local_creation" +%s)
  remote_creation=$(ssh $ZSYNC_SSHPARAMS "root@$desthost" "zfs list -t snapshot -H -d 1 -o creation | tail -1")
  remote_creation=$(date -d "$remote_creation" +%s)

  localguid=$(zfs list -t snapshot -H -d 1 -o guid | tail -1)
  remoteguid=$(ssh $ZSYNC_SSHPARAMS "root@$desthost" "zfs list -t snapshot -H -d 1 -o guid | tail -1")

  debugprint "Local creation: $local_creation - Remote creation: $remote_creation"
  debugprint "Local guid: $localguid - Remote guid: $remoteguid"

  if [[ $local_creation -gt $remote_creation ]]; then
    # happens when master couldn't send its snapshots to backup for w/e reason
    # master would end up being in front
    debugprint "Local ${srcfs}@${ZSYNC_PREFIX}_0($localguid) taken at $local_creation " \
      "is MORE recent than remote ${srcfs}@${ZSYNC_PREFIX}_0($remoteguid) taken at $remote_creation" 

    # find start and end snaps
    start_snap=$(zfs list -H -t snapshot -d 1 -o name,guid,creation | grep "$remoteguid" | awk '{print $1}')
    end_snap=${srcfs}@${ZSYNC_PREFIX}_0

    # extra debug
    debugprint "$(printf '%.0s=' {1..18} && printf ' LOCAL SNAPS ' && printf '%.0s=' {1..19}; echo)"
    debugprint "$(zfs list -H -t snapshot -o name,guid,creation)"
    debugprint "$(printf '%.0s=' {1..18} && printf ' REMOTE SNAPS ' && printf '%.0s=' {1..18} ; echo)"
    debugprint "$(ssh $ZSYNC_SSHPARAMS "root@$desthost" "zfs list -H -t snapshot -o name,guid,creation")"

    if [[ "$startsnap" != "" ]] ; then
      # if start snap was found in master send incremental
      # seeing: cannot unmount '/tank/cold': unmount failed (zfs recv -M not supported on linux)
      printf "Will send the difference between $start_snap AND $end_snap to equalize\n"
      debugprint "zfs send -v -R -I $start_snap $end_snap | ssh -T $desthost zfs recv -o readonly=on -F -v $destfs"
      zfs send -v -R -I $start_snap $end_snap | ssh -T $desthost zfs recv -o readonly=on -F -v $destfs
    else
      # for w/e reason if remote latest isn't found in master then send full
      printf "Anchor snap '$remoteguid' not in master, resetting snapshots ...\n"
      zsync_resetsnaps $srcfs $desthost $destfs
      # calling init to resync clean
      zsync_init $srcfs $desthost $destfs
    fi
  else  
    # happens when master rolled back, which makes him late compared to backup 
    # master ex: zfs list -t snapshot -H -o name | grep bk_1 | xargs -I {} zfs rollback -Rrf {}
    # but master is still reference and we should push the changes to backup
    debugprint "Local ${srcfs}@${ZSYNC_PREFIX}_0($localguid) taken at $local_creation " \
      "is LESS recent than remote ${srcfs}@${ZSYNC_PREFIX}_0($remoteguid) taken at $remote_creation" 

    # extra debug
    debugprint "$(printf '%.0s=' {1..18} && printf ' LOCAL SNAPS ' && printf '%.0s=' {1..19}; echo)"
    debugprint "$(zfs list -H -t snapshot -o name,guid,creation)"
    debugprint "$(printf '%.0s=' {1..18} && printf ' REMOTE SNAPS ' && printf '%.0s=' {1..18} ; echo)"
    debugprint "$(ssh $ZSYNC_SSHPARAMS "root@$desthost" "zfs list -H -t snapshot -o name,guid,creation")"

    # get remote name from latest local guid
    debugprint "Remote guid: $remoteguid not equal to local guid: $localguid"
    remotename=$(ssh $ZSYNC_SSHPARAMS "root@$desthost" "zfs list -t snapshot -H -d 1 -o name,guid | grep '$localguid'")

    if [[ "$remotename" != "" ]] ; then
      # if we found master anchor in backup
      remotename=$(echo $remotename |  tr -s '\t' ' ' | tr -s ' ' | cut -d' ' -f1)
      remotesnapname="$( echo $remotename | cut -d'@' -f2)"
      debugprint "Remote name: $remotename - Remote snapname: $remotesnapname"
      # destroy doesn't change the file system, must rollback
      # rollback must be done on each elements (no recursion available)
      debugprint "ssh $ZSYNC_SSHPARAMS "root@$desthost" 'zfs list -t snapshot -H -o name | grep "$remotesnapname"'"
      rolls=$(ssh $ZSYNC_SSHPARAMS "root@$desthost" "zfs list -t snapshot -H -o name | grep $remotesnapname")
      # then we just rollback backup
      for r in $rolls; do
        debugprint "ssh $ZSYNC_SSHPARAMS "root@$desthost" 'zfs rollback -Rr $r'"
        ssh $ZSYNC_SSHPARAMS "root@$desthost" "zfs rollback -Rr $r"
      done
      # then we adjust snap_i by renaming them
      printf "Re-sequencing master and backup snapshots\n"
      line=0
      snapshot_list=($(zfs list -t snapshot -d 1 -H -o name))
      count=${#snapshot_list[@]}
      for snapshot in "${snapshot_list[@]}"; do
          idx=$(($count - $line - 1))
          debugprint "zfs rename -r $snapshot $srcfs@${ZSYNC_PREFIX}_$idx"
          zfs rename -r "$snapshot" "$srcfs@${ZSYNC_PREFIX}_$idx"

          debugprint "ssh $ZSYNC_SSHPARAMS root@$desthost zfs rename -r $snapshot $destfs@${ZSYNC_PREFIX}_$idx"
          ssh $ZSYNC_SSHPARAMS "root@$desthost" "zfs rename -r $snapshot $destfs@${ZSYNC_PREFIX}_$idx"
          line=$(($line + 1))
      done 

    else
      # if we cannot find master anchor in backup
      printf "Anchor snap '$localguid' not found backup, resetting snapshots ...\n"
      zsync_resetsnaps $srcfs $desthost $destfs
      # calling init to resync clean
      zsync_init $srcfs $desthost $destfs
    fi
  fi

  exit 1

}

# Simply destroys all master and backup snapshot
# Used when gaps have been found and just before doing a full resend
zsync_resetsnaps() {
  typeset srcfs desthost destfs
  srcfs="$1"
  desthost="$2"
  destfs="$3"

  debugprint "ssh $ZSYNC_SSHPARAMS "root@$desthost" "zfs list -t snapshot -H -d 1 -o name""

  rolls=$(ssh $ZSYNC_SSHPARAMS "root@$desthost" "zfs list -t snapshot -H -d 1 -o name")
  for r in $rolls; do
    printf "Destroying remote snapshots"
    debugprint "ssh $ZSYNC_SSHPARAMS "root@$desthost" 'zfs destroy -Rr $r'"
    ssh $ZSYNC_SSHPARAMS "root@$desthost" "zfs destroy -Rr $r"
  done

  rolls=$(zfs list -t snapshot -H -d 1 -o name)
  for r in $rolls; do
    printf "Destroying local snapshots"
    debugprint "zfs destroy -Rr $r"
    zfs destroy -Rr $r
  done
}

# Perform initial full send
zsync_init() {
  typeset srcfs desthost destfs
  srcfs="$1"
  desthost="$2"
  destfs="$3"

  printf "Performing full replication from local $srcfs to $desthost $destfs\n"

  debugprint "zfs snapshot -r ${srcfs}@${ZSYNC_PREFIX}_0"
  zfs snapshot -r ${srcfs}@${ZSYNC_PREFIX}_0
  debugprint "zfs send -R ${srcfs}@${ZSYNC_PREFIX}_0 | ssh $ZSYNC_SSHPARAMS $desthost zfs recv -o readonly=on -F $destfs"
  zfs send -R ${srcfs}@${ZSYNC_PREFIX}_0 | ssh $ZSYNC_SSHPARAMS $desthost zfs recv -o readonly=on -F $destfs
}

# Perform rolling snapshots from master to backup
zsync_roll() {
  typeset srcfs desthost destfs
  srcfs="$1"
  desthost="$2"
  destfs="$3"

  printf "Performing rolling snapshot from local $srcfs to $desthost $destfs\n"

  # always destroy snapshot that are above retention
  debugprint "zfs destroy -r ${srcfs}@${ZSYNC_PREFIX}_$ZSYNC_RETENTION > /dev/null 2>&1"
  zfs destroy -r ${srcfs}@${ZSYNC_PREFIX}_$ZSYNC_RETENTION > /dev/null 2>&1

  # roll
  for ((i=$ZSYNC_RETENTION-1; i>=0; i--)); do
      debugprint "zfs rename -r ${srcfs}@${ZSYNC_PREFIX}_$i ${srcfs}@${ZSYNC_PREFIX}_$((i+1)) > /dev/null 2>&1"
      zfs rename -r ${srcfs}@${ZSYNC_PREFIX}_$i ${srcfs}@${ZSYNC_PREFIX}_$((i+1)) > /dev/null 2>&1
  done
  # take new snap_0
  debugprint "zfs snapshot -r ${srcfs}@${ZSYNC_PREFIX}_0"
  zfs snapshot -r ${srcfs}@${ZSYNC_PREFIX}_0
  # send the increment between now (0) and before (1)
  debugprint "zfs send -R -I ${srcfs}@${ZSYNC_PREFIX}_1 ${srcfs}@${ZSYNC_PREFIX}_0 | ssh $ZSYNC_SSHPARAMS $desthost zfs recv -o readonly=on -F $destfs"
  zfs send -R -I ${srcfs}@${ZSYNC_PREFIX}_1 ${srcfs}@${ZSYNC_PREFIX}_0 | ssh $ZSYNC_SSHPARAMS $desthost zfs recv -o readonly=on -F $destfs
}

main "${@}"
